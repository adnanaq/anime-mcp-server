Based on my research, I found several proven approaches that address your challenge. Here's what the industry is actually doing:

  Approach: Dynamic Tool Composition with Context-Aware Routing

  This is emerging as the standard pattern in modern LLM applications:

  1. Context-Driven Tool Selection

  @mcp.tool
  async def search_anime(
      query: str,
      context: Dict[str, Any] = None,  # LLM provides context about intent
  ) -> List[Dict[str, Any]]:
      """
      Smart anime search that dynamically routes based on query context.

      Context examples:
      - {"platform_preference": "mal", "feature": "broadcast_schedule"}
      - {"platform_preference": "anilist", "feature": "adult_content"}
      - {"multi_platform": True, "comparison": ["ratings", "metadata"]}
      """

  2. Capability Discovery Pattern

  @mcp.tool
  async def get_anime_search_capabilities() -> Dict[str, Any]:
      """
      Returns available search capabilities by platform.
      LLM calls this first to understand what's possible.
      """
      return {
          "mal": {
              "unique_features": ["broadcast_day", "nsfw_filtering", "detailed_ratings"],
              "best_for": ["scheduling", "content_filtering", "popularity"]
          },
          "anilist": {
              "unique_features": ["adult_content", "country_origin", "modern_ui_data"],
              "best_for": ["international_content", "community_features"]
          },
          "universal": {
              "features": ["text_search", "genre_filter", "year_filter"],
              "best_for": ["general_discovery", "cross_platform_results"]
          }
      }

  3. Conditional Parameter Injection

  @mcp.tool
  async def search_anime_advanced(
      query: str,
      platform_intent: Optional[str] = None,  # "mal_broadcast", "anilist_adult", "universal"
      **kwargs  # Dynamic platform-specific params
  ) -> List[Dict[str, Any]]:
      """
      Advanced search with dynamic parameter injection based on intent.

      Examples:
      - platform_intent="mal_broadcast" + broadcast_day="monday"
      - platform_intent="anilist_adult" + is_adult=True + country="KR"
      """

      if platform_intent == "mal_broadcast":
          return await _search_mal_with_broadcast(**kwargs)
      elif platform_intent == "anilist_adult":
          return await _search_anilist_with_adult_filters(**kwargs)
      else:
          return await _search_universal(**kwargs)

  Why This Works Better

  1. LLM Discovery: LLM learns platform capabilities through the capabilities tool
  2. Intent-Based Routing: LLM declares intent, not just parameters
  3. Dynamic Parameters: **kwargs allows platform-specific params without schema bloat
  4. Graceful Degradation: Falls back to universal search if platform-specific fails

  This pattern is used by: Google Vertex AI, OpenAI Function Calling, Anthropic MCP servers, and modern AI frameworks.

  Sound better than the approaches I suggested earlier?


> which one are you suggesting?


● I'm suggesting Approach #3: Conditional Parameter Injection as the best solution.

  Here's why:

  @mcp.tool
  async def search_anime_advanced(
      query: str,
      platform_intent: Optional[str] = None,  # "mal_broadcast", "anilist_adult", "universal"
      **kwargs  # Dynamic platform-specific params
  ) -> List[Dict[str, Any]]:
      """
      Advanced search with dynamic parameter injection based on intent.

      Examples:
      - platform_intent="mal_broadcast" + broadcast_day="monday"
      - platform_intent="anilist_adult" + is_adult=True + country="KR"
      """

      if platform_intent == "mal_broadcast":
          return await _search_mal_with_broadcast(**kwargs)
      elif platform_intent == "anilist_adult":
          return await _search_anilist_with_adult_filters(**kwargs)
      else:
          return await _search_universal(**kwargs)

  Why This Is Best:

  1. Clean Schema: No 40+ parameter bloat in the main tool
  2. LLM Flexibility: LLM can choose any platform with platform_intent
  3. Dynamic Parameters: **kwargs accepts any platform-specific params
  4. Intent-Driven: LLM declares what it wants to do, not just parameters
  5. Discoverable: LLM can learn platform capabilities through documentation

  User Query Examples:

  - "Find SFW anime on MAL" → platform_intent="mal_content", nsfw="white"
  - "Korean adult anime" → platform_intent="anilist_adult", country="KR", is_adult=True
  - "Studio Ghibli movies" → platform_intent="universal", studios=["Studio Ghibli"]

  This gives LLMs maximum flexibility while keeping the architecture clean and extensible.

  Do you agree this solves your flexibility requirement?


> so how would that work in our case, wouldn't there be lot of if statements?


● You're absolutely right! That approach would create a massive if-statement nightmare:

  @mcp.tool
  async def search_anime_advanced(query: str, platform_intent: str = None, **kwargs):
      if platform_intent == "mal_broadcast":
          return await _search_mal_with_broadcast(**kwargs)
      elif platform_intent == "mal_rating":
          return await _search_mal_with_rating(**kwargs)
      elif platform_intent == "mal_nsfw":
          return await _search_mal_with_nsfw(**kwargs)
      elif platform_intent == "anilist_adult":
          return await _search_anilist_with_adult(**kwargs)
      elif platform_intent == "anilist_country":
          return await _search_anilist_with_country(**kwargs)
      elif platform_intent == "kitsu_age_rating":
          return await _search_kitsu_with_age_rating(**kwargs)
      # ... 50+ more if statements for every platform + feature combination!
      else:
          return await _search_universal(**kwargs)

  That's terrible architecture!

  Better Approach: Mapper Registry Pattern

  @mcp.tool
  async def search_anime(
      query: str,
      platform: str = "auto",  # "mal", "anilist", "kitsu", "auto"
      **platform_params  # Any platform-specific params
  ) -> List[Dict[str, Any]]:
      """
      Universal anime search with intelligent platform routing.

      Platform-specific examples:
      - platform="mal", broadcast_day="monday", nsfw="white"
      - platform="anilist", is_adult=True, country_of_origin="KR"
      - platform="auto" (chooses best platform automatically)
      """

      # Convert kwargs to universal params + platform-specific params
      universal_params, platform_specific = _extract_params(**platform_params)

      # Use existing mapper registry (no if statements!)
      mapper = MapperRegistry.get_mapper(platform)
      platform_query = mapper.to_platform_params(universal_params, platform_specific)

      # Call appropriate API
      return await PlatformAPIRegistry.search(platform, platform_query)

  Implementation:

  class MapperRegistry:
      _mappers = {
          "mal": MALMapper,
          "anilist": AniListMapper,
          "kitsu": KitsuMapper,
          # etc.
      }

      @classmethod
      def get_mapper(cls, platform: str):
          return cls._mappers.get(platform, UniversalMapper)

  No if statements needed! The existing mapper architecture handles everything.